;==========================================
; ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ И СТРУКТУРА ДАННЫХ
;==========================================
section .data
    prompt_n db "Введите размер массивов N (1-100): ", 0  ; Приглашение для ввода размера
    prompt_a db "Введите элементы массива A (по одному):", 10, 0  ; Приглашение для ввода массива A
    prompt_b db "Введите элементы массива B (по одному):", 10, 0  ; Приглашение для ввода массива B
    input_fmt db "%d", 0  ; Формат для функции scanf (целое число)
    output_yes db "Да", 10, 0  ; Сообщение "Да" (массивы содержат одинаковые элементы)
    output_no db "Нет", 10, 0  ; Сообщение "Нет" (массивы не содержат одинаковые элементы)
    error_msg db "Ошибка ввода! Пожалуйста, введите целое число.", 10, 0  ; Сообщение об ошибке ввода

section .bss
    array_a resd 100   ; Массив A (резервируем место для 100 элементов, каждый по 4 байта)
    array_b resd 100   ; Массив B (резервируем место для 100 элементов, каждый по 4 байта)
    visited resd 100   ; Массив для отметки посещенных элементов в B (для поиска соответствий)
    n resd 1           ; Размер массивов (одно 4-байтное целое число)

;==========================================
; ИСПОЛНЯЕМЫЙ КОД ПРОГРАММЫ
;==========================================
section .text
    global main
    extern printf, scanf, getchar  ; Внешние функции из libc

;==========================================
; ОСНОВНОЙ БЛОК ПРОГРАММЫ
; Точка входа и управление потоком выполнения
;==========================================
main:
    push ebp          ; Сохраняем базовый указатель стека
    mov ebp, esp      ; Устанавливаем новый базовый указатель

    ;----------------------------------------
    ; БЛОК ВВОДА: Запрос размера массивов
    ;----------------------------------------
    push prompt_n     ; Передаем адрес строки приглашения как параметр для printf
    call printf       ; Вызываем функцию printf для вывода приглашения
    add esp, 4        ; Очищаем стек (удаляем параметр)

    ;----------------------------------------
    ; БЛОК ВВОДА: Считывание значения N
    ;----------------------------------------
    push n            ; Адрес переменной для сохранения введенного значения
    push input_fmt    ; Формат ввода ("%d")
    call scanf        ; Вызываем функцию scanf для считывания числа
    add esp, 8        ; Очищаем стек (удаляем 2 параметра)

    ;----------------------------------------
    ; БЛОК ПРОВЕРКИ: Валидация размера N
    ;----------------------------------------
    mov eax, [n]      ; Загружаем введенное значение N в регистр eax
    cmp eax, 1        ; Сравниваем N с минимальным значением 1
    jl invalid_n      ; Если N < 1, переходим к обработке некорректного ввода
    cmp eax, 100      ; Сравниваем N с максимальным значением 100
    jg invalid_n      ; Если N > 100, переходим к обработке некорректного ввода
    jmp input_array_a ; Если N корректно, переходим к вводу массива A

;----------------------------------------
; БЛОК ОБРАБОТКИ ОШИБОК: Некорректный размер N
;----------------------------------------
invalid_n:
    ; Выводим сообщение об ошибке
    push error_msg    ; Передаем адрес сообщения об ошибке как параметр
    call printf       ; Вызываем функцию printf для вывода сообщения
    add esp, 4        ; Очищаем стек (удаляем параметр)
    
    ; Очищаем буфер ввода
clear_buffer_n:
    call getchar      ; Считываем один символ из буфера ввода
    cmp al, 10        ; Сравниваем с символом новой строки (ASCII 10)
    jne clear_buffer_n ; Если не новая строка, продолжаем очистку буфера
    
    jmp main          ; Возвращаемся к началу программы для повторного ввода

;==========================================
; БЛОК ВВОДА МАССИВОВ: Ввод массива A
;==========================================
input_array_a:
    ; Выводим приглашение для ввода массива A
    push prompt_a     ; Передаем адрес строки приглашения как параметр
    call printf       ; Вызываем функцию printf для вывода приглашения
    add esp, 4        ; Очищаем стек (удаляем параметр)

    ; Инициализация для ввода элементов массива A
    xor ebx, ebx      ; ebx = 0 (индекс текущего элемента в массиве)

;----------------------------------------
; Подблок: Цикл ввода элементов массива A
;----------------------------------------
input_loop_a:
    mov eax, [n]      ; Загружаем N в eax
    cmp ebx, eax      ; Сравниваем текущий индекс с размером массива
    jge input_array_b ; Если ввели все элементы (ebx >= N), переходим к вводу B
    
    ; Считываем один элемент массива
    lea eax, [array_a + ebx*4]  ; Вычисляем адрес элемента массива (base + index*size)
    push eax          ; Передаем адрес элемента как параметр для scanf
    push input_fmt    ; Передаем формат ввода как параметр
    call scanf        ; Вызываем функцию scanf для считывания элемента
    add esp, 8        ; Очищаем стек (удаляем 2 параметра)
    
    ; Проверяем успешность считывания
    cmp eax, 1        ; scanf возвращает количество успешно считанных значений
    je valid_input_a  ; Если считан 1 элемент, переходим к обработке корректного ввода
    
    ; Обработка ошибки ввода
    push error_msg    ; Передаем адрес сообщения об ошибке как параметр
    call printf       ; Вызываем функцию printf для вывода сообщения
    add esp, 4        ; Очищаем стек (удаляем параметр)
    
    ; Очищаем буфер ввода
clear_buffer_a:
    call getchar      ; Считываем один символ из буфера ввода
    cmp al, 10        ; Сравниваем с символом новой строки (ASCII 10)
    jne clear_buffer_a ; Если не новая строка, продолжаем очистку буфера
    
    jmp input_loop_a  ; Возвращаемся к вводу текущего элемента
    
valid_input_a:
    inc ebx           ; Увеличиваем индекс (переходим к следующему элементу)
    jmp input_loop_a  ; Возвращаемся к началу цикла ввода

;==========================================
; БЛОК ВВОДА МАССИВОВ: Ввод массива B
;==========================================
input_array_b:
    ; Выводим приглашение для ввода массива B
    push prompt_b     ; Передаем адрес строки приглашения как параметр
    call printf       ; Вызываем функцию printf для вывода приглашения
    add esp, 4        ; Очищаем стек (удаляем параметр)

    ; Инициализация для ввода элементов массива B
    xor ebx, ebx      ; ebx = 0 (индекс текущего элемента в массиве)

;----------------------------------------
; Подблок: Цикл ввода элементов массива B
;----------------------------------------
input_loop_b:
    mov eax, [n]      ; Загружаем N в eax
    cmp ebx, eax      ; Сравниваем текущий индекс с размером массива
    jge compare_arrays ; Если ввели все элементы (ebx >= N), переходим к сравнению
    
    ; Считываем один элемент массива
    lea eax, [array_b + ebx*4]  ; Вычисляем адрес элемента массива (base + index*size)
    push eax          ; Передаем адрес элемента как параметр для scanf
    push input_fmt    ; Передаем формат ввода как параметр
    call scanf        ; Вызываем функцию scanf для считывания элемента
    add esp, 8        ; Очищаем стек (удаляем 2 параметра)
    
    ; Проверяем успешность считывания
    cmp eax, 1        ; scanf возвращает количество успешно считанных значений
    je valid_input_b  ; Если считан 1 элемент, переходим к обработке корректного ввода
    
    ; Обработка ошибки ввода
    push error_msg    ; Передаем адрес сообщения об ошибке как параметр
    call printf       ; Вызываем функцию printf для вывода сообщения
    add esp, 4        ; Очищаем стек (удаляем параметр)
    
    ; Очищаем буфер ввода
clear_buffer_b:
    call getchar      ; Считываем один символ из буфера ввода
    cmp al, 10        ; Сравниваем с символом новой строки (ASCII 10)
    jne clear_buffer_b ; Если не новая строка, продолжаем очистку буфера
    
    jmp input_loop_b  ; Возвращаемся к вводу текущего элемента
    
valid_input_b:
    inc ebx           ; Увеличиваем индекс (переходим к следующему элементу)
    jmp input_loop_b  ; Возвращаемся к началу цикла ввода

;==========================================
; БЛОК СРАВНЕНИЯ МАССИВОВ
; Проверяет, содержат ли массивы одинаковые элементы
;==========================================
compare_arrays:
    ; Инициализируем массив visited нулями (отмечаем, что ни один элемент B еще не использован)
    mov ecx, [n]      ; Загружаем N в ecx для использования в цикле
    xor ebx, ebx      ; ebx = 0 (индекс в массиве)
init_visited:
    mov dword [visited + ebx*4], 0  ; Записываем 0 в visited[ebx]
    inc ebx           ; Увеличиваем индекс
    cmp ebx, ecx      ; Сравниваем с размером массива
    jl init_visited   ; Если не достигли конца, продолжаем инициализацию

    ;----------------------------------------
    ; Подблок: Внешний цикл по элементам A
    ;----------------------------------------
    xor esi, esi      ; esi = 0 (индекс в массиве A)
outer_loop:
    mov ecx, [n]      ; Загружаем N в ecx
    cmp esi, ecx      ; Сравниваем текущий индекс с размером массива
    jge arrays_equal  ; Если прошли весь массив A, значит все элементы A имеют соответствие в B

    mov eax, [array_a + esi*4]  ; Загружаем текущий элемент из A в eax
    
    ;----------------------------------------
    ; Подблок: Внутренний цикл - поиск соответствия в B
    ;----------------------------------------
    xor edi, edi      ; edi = 0 (индекс в массиве B)
inner_loop:
    cmp edi, ecx      ; Сравниваем индекс с размером массива
    jge arrays_not_equal  ; Если прошли весь B и не нашли соответствие, массивы различны
    
    ; Проверяем, был ли элемент B уже использован
    cmp dword [visited + edi*4], 1  ; Проверяем visited[edi] == 1
    je next_b         ; Если элемент уже использован, переходим к следующему
    
    ; Сравниваем элементы A[esi] и B[edi]
    cmp eax, [array_b + edi*4]  ; Сравниваем текущие элементы массивов
    jne next_b        ; Если не равны, проверяем следующий элемент B
    
    ; Нашли соответствие, отмечаем элемент B как использованный
    mov dword [visited + edi*4], 1  ; Устанавливаем visited[edi] = 1
    jmp next_a        ; Переходим к следующему элементу A
    
next_b:
    inc edi           ; Увеличиваем индекс B
    jmp inner_loop    ; Возвращаемся к началу внутреннего цикла
    
next_a:
    inc esi           ; Увеличиваем индекс A
    jmp outer_loop    ; Возвращаемся к началу внешнего цикла

;----------------------------------------
; Подблок: Проверка на равенство массивов
;----------------------------------------
arrays_equal:
    ; Проверяем, что все элементы массива B были использованы
    xor ebx, ebx      ; ebx = 0 (индекс в массиве visited)
    mov ecx, [n]      ; Загружаем N в ecx
check_all_visited:
    cmp ebx, ecx      ; Сравниваем индекс с размером массива
    jge print_yes     ; Если проверили все элементы, печатаем "Да"
    
    cmp dword [visited + ebx*4], 0  ; Проверяем visited[ebx] == 0
    je arrays_not_equal  ; Если найден неиспользованный элемент, массивы не равны
    
    inc ebx           ; Увеличиваем индекс
    jmp check_all_visited  ; Продолжаем проверку

;==========================================
; БЛОК ВЫВОДА РЕЗУЛЬТАТОВ
;==========================================
print_yes:
    ; Выводим "Да" (массивы содержат одинаковые элементы)
    push output_yes   ; Передаем адрес строки как параметр
    call printf       ; Вызываем функцию printf для вывода сообщения
    add esp, 4        ; Очищаем стек (удаляем параметр)
    jmp exit          ; Переходим к завершению программы
    
arrays_not_equal:
    ; Выводим "Нет" (массивы содержат разные элементы)
    push output_no    ; Передаем адрес строки как параметр
    call printf       ; Вызываем функцию printf для вывода сообщения
    add esp, 4        ; Очищаем стек (удаляем параметр)
    
;==========================================
; БЛОК ЗАВЕРШЕНИЯ ПРОГРАММЫ
;==========================================
exit:
    ; Завершаем программу
    mov esp, ebp      ; Восстанавливаем указатель стека
    pop ebp           ; Восстанавливаем сохраненный базовый указатель
    xor eax, eax      ; Устанавливаем код возврата 0 (успешное завершение)
    ret               ; Возврат из функции main
