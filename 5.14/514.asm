;==========================================
; ЗАДАНИЕ 5.14 - ОБРАБОТКА МАССИВА ЧИСЕЛ
;==========================================
; Компиляция и сборка:
;   nasm -f elf32 514.asm -o 514.o
;   gcc -m32 514.o -o 514
;
; Запуск: ./514

section .data
    prompt db "Введите 10 целых чисел (по одному):", 10, 0
    input_fmt db "%d", 0
    output_array db "Модифицированный массив: ", 0
    output_num db "%d ", 0
    newline db 10, 0
    sum_msg db "Сумма чисел из отрезка [2;9]: %d", 10, 0
    count_msg db "Количество чисел из отрезка [2;9]: %d", 10, 0
    error_msg db "Ошибка ввода! Пожалуйста, введите целое число.", 10, 0

section .bss
    array resd 10     ; массив из 10 целых чисел (4 байта каждое)

;==========================================
; ИСПОЛНЯЕМЫЙ КОД ПРОГРАММЫ
;==========================================
section .text
    global main
    extern printf, scanf, getchar

main:
    push ebp          ; Сохраняем базовый указатель
    mov ebp, esp      ; Устанавливаем новый базовый указатель

    ;==========================================
    ; БЛОК ВЫВОДА ПРИГЛАШЕНИЯ ДЛЯ ВВОДА
    ;==========================================
    push prompt       ; Загружаем в стек адрес строки приглашения
    call printf       ; Вызываем функцию printf для вывода приглашения
    add esp, 4        ; Очищаем стек после вызова функции

    ;==========================================
    ; БЛОК ВВОДА МАССИВА ЧИСЕЛ
    ;==========================================
    xor ebx, ebx      ; ebx = 0 (индекс в массиве)

input_loop:
    ;----------------------------------------
    ; Подблок: Проверка завершения ввода
    ;----------------------------------------
    cmp ebx, 10       ; Сравниваем индекс с 10
    jge process_array ; Если уже введено 10 чисел, переходим к обработке
    
    ;----------------------------------------
    ; Подблок: Чтение числа с клавиатуры
    ;----------------------------------------
    lea eax, [array + ebx*4]  ; Вычисляем адрес текущего элемента массива
    push eax          ; Помещаем адрес в стек (куда будет записано число)
    push input_fmt    ; Помещаем в стек формат ввода ("%d")
    call scanf        ; Вызываем scanf для чтения целого числа
    add esp, 8        ; Очищаем стек после вызова scanf
    
    ;----------------------------------------
    ; Подблок: Проверка корректности ввода
    ;----------------------------------------
    cmp eax, 1        ; Сравниваем результат scanf с 1 (успешный ввод)
    je valid_input    ; Если ввод успешный, переходим к обработке
    
    ;----------------------------------------
    ; Подблок: Обработка ошибки ввода
    ;----------------------------------------
    push error_msg    ; Помещаем адрес сообщения об ошибке в стек
    call printf       ; Выводим сообщение об ошибке
    add esp, 4        ; Очищаем стек
    
    ;----------------------------------------
    ; Подблок: Очистка буфера ввода
    ;----------------------------------------
clear_buffer:
    call getchar      ; Читаем символ из буфера
    cmp al, 10        ; Проверяем, является ли символ переводом строки
    jne clear_buffer  ; Если нет, продолжаем чтение
    
    jmp input_loop    ; Повторяем ввод для того же индекса
    
    ;----------------------------------------
    ; Подблок: Обработка корректного ввода
    ;----------------------------------------
valid_input:
    inc ebx           ; Увеличиваем индекс массива
    jmp input_loop    ; Переходим к вводу следующего элемента
    
;==========================================
; БЛОК ОБРАБОТКИ И ВЫВОДА МАССИВА
;==========================================
process_array:
    ;----------------------------------------
    ; Подблок: Вывод заголовка массива
    ;----------------------------------------
    push output_array ; Помещаем адрес строки заголовка в стек
    call printf       ; Выводим заголовок
    add esp, 4        ; Очищаем стек
    
    ;----------------------------------------
    ; Подблок: Инициализация переменных
    ;----------------------------------------
    xor ebx, ebx      ; индекс в массиве = 0
    xor esi, esi      ; сумма чисел из отрезка [2;9] = 0
    xor edi, edi      ; количество чисел из отрезка [2;9] = 0
    
    ;----------------------------------------
    ; Подблок: Цикл обработки элементов массива
    ;----------------------------------------
process_loop:
    cmp ebx, 10       ; Сравниваем индекс с размером массива
    jge output_results ; Если все элементы обработаны, переходим к выводу результатов
    
    mov eax, [array + ebx*4]  ; Загружаем текущий элемент массива в eax
    
    ;----------------------------------------
    ; Подблок: Проверка принадлежности к отрезку [2;9]
    ;----------------------------------------
    cmp eax, 2        ; Сравниваем число с нижней границей отрезка
    jl check_replacement  ; Если меньше 2, переходим к проверке замены
    cmp eax, 9        ; Сравниваем число с верхней границей отрезка
    jg check_replacement  ; Если больше 9, переходим к проверке замены
    
    ; Число в диапазоне [2;9]
    add esi, eax      ; Добавляем число к сумме
    inc edi           ; Увеличиваем счетчик чисел
    
    ;----------------------------------------
    ; Подблок: Проверка условий замены числа
    ;----------------------------------------
check_replacement:
    cmp eax, 2        ; Проверяем, больше ли число 2
    jle skip_replacement ; Если число <= 2, пропускаем замену
    
    ; Заменяем число на 0, если оно > 2
    mov dword [array + ebx*4], 0  ; Записываем 0 в текущий элемент массива
    
    ;----------------------------------------
    ; Подблок: Вывод текущего элемента массива
    ;----------------------------------------
skip_replacement:
    push dword [array + ebx*4]  ; Помещаем в стек текущий элемент массива
    push output_num   ; Помещаем в стек формат вывода
    call printf       ; Выводим текущий элемент
    add esp, 8        ; Очищаем стек
    
    inc ebx           ; Увеличиваем индекс
    jmp process_loop  ; Переходим к обработке следующего элемента
    
;==========================================
; БЛОК ВЫВОДА РЕЗУЛЬТАТОВ
;==========================================
output_results:
    ;----------------------------------------
    ; Подблок: Вывод перевода строки
    ;----------------------------------------
    push newline      ; Помещаем адрес перевода строки в стек
    call printf       ; Выводим перевод строки
    add esp, 4        ; Очищаем стек
    
    ;----------------------------------------
    ; Подблок: Вывод суммы чисел из отрезка [2;9]
    ;----------------------------------------
    push esi          ; Помещаем сумму в стек
    push sum_msg      ; Помещаем формат вывода суммы в стек
    call printf       ; Выводим сумму
    add esp, 8        ; Очищаем стек
    
    ;----------------------------------------
    ; Подблок: Вывод количества чисел из отрезка [2;9]
    ;----------------------------------------
    push edi          ; Помещаем количество в стек
    push count_msg    ; Помещаем формат вывода количества в стек
    call printf       ; Выводим количество
    add esp, 8        ; Очищаем стек
    
    ;==========================================
    ; БЛОК ЗАВЕРШЕНИЯ ПРОГРАММЫ
    ;==========================================
    mov esp, ebp      ; Восстанавливаем указатель стека
    pop ebp           ; Восстанавливаем базовый указатель
    xor eax, eax      ; Устанавливаем код возврата 0
    ret               ; Возвращаемся из функции main