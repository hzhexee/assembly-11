;==========================================
; ПРОГРАММА ПОДСЧЁТА СЛОВ В ПРЕДЛОЖЕНИИ
;==========================================
; Компиляция и сборка:
;   nasm -f elf32 64.asm -o 64.o
;   ld -m elf_i386 64.o -o 64
;
; Запуск: ./64

section .data
    prompt db "Введите предложение: ", 0
    prompt_len equ $ - prompt
    result_msg db "Количество слов: ", 0
    result_len equ $ - result_msg
    newline db 10, 0

section .bss
    buffer resb 1024       ; Буфер для ввода
    result resb 20         ; Для хранения количества слов в виде строки

;==========================================
; ИСПОЛНЯЕМЫЙ КОД ПРОГРАММЫ
;==========================================
section .text
    global _start

_start:
    ;==========================================
    ; БЛОК ВВОДА-ВЫВОДА
    ;==========================================
    
    ;----------------------------------------
    ; Подблок: Вывод приглашения для ввода
    ;----------------------------------------
    mov eax, 4              ; sys_write - системный вызов для записи
    mov ebx, 1              ; stdout - файловый дескриптор стандартного вывода
    mov ecx, prompt         ; сообщение для вывода - приглашение ввести предложение
    mov edx, prompt_len     ; длина сообщения - количество байт для вывода
    int 0x80                ; программное прерывание для вызова функции ядра

    ;----------------------------------------
    ; Подблок: Чтение ввода пользователя
    ;----------------------------------------
    mov eax, 3              ; sys_read - системный вызов для чтения
    mov ebx, 0              ; stdin - файловый дескриптор стандартного ввода
    mov ecx, buffer         ; буфер для ввода - область памяти для сохранения введенного текста
    mov edx, 1024           ; размер буфера - максимальное количество байт для чтения
    int 0x80                ; вызов функции ядра для чтения данных

    ;----------------------------------------
    ; Подблок: Сохранение размера входных данных
    ;----------------------------------------
    mov esi, eax            ; сохраняем в esi количество прочитанных байт

    ;==========================================
    ; БЛОК ОБРАБОТКИ ДАННЫХ
    ;==========================================
    
    ;----------------------------------------
    ; Подблок: Инициализация переменных для подсчёта
    ;----------------------------------------
    xor edi, edi            ; edi = 0 (текущая позиция в буфере)
    xor ebp, ebp            ; ebp = 0 (счетчик слов)
    mov edx, 0              ; edx = 0 (флаг: 0=вне слова, 1=внутри слова)

    ;----------------------------------------
    ; Подблок: Основной цикл подсчёта слов
    ;----------------------------------------
count_loop:
    cmp edi, esi            ; Сравниваем текущую позицию с общим количеством прочитанных байт
    jge end_count           ; Если достигли конца буфера, завершаем подсчет

    movzx eax, byte [buffer + edi]  ; Получаем текущий символ с расширением нулями
    
    ;----------------------------------------
    ; Подблок: Проверка на разделитель
    ;----------------------------------------
    cmp al, ' '             ; Проверка на пробел
    je is_delimiter
    cmp al, 10              ; Проверка на перевод строки
    je is_delimiter
    cmp al, 9               ; Проверка на символ табуляции
    je is_delimiter
    
    ;----------------------------------------
    ; Подблок: Обработка символа-части слова
    ;----------------------------------------
    cmp edx, 0              ; Проверяем, находимся ли вне слова (флаг=0)
    jne continue_word       ; Если уже внутри слова (флаг=1), пропускаем инкремент счетчика
    
    inc ebp                 ; Увеличиваем счетчик слов - обнаружили начало нового слова
    mov edx, 1              ; Устанавливаем флаг, что мы внутри слова
    jmp next_char           ; Переходим к обработке следующего символа

    ;----------------------------------------
    ; Подблок: Обработка разделителя
    ;----------------------------------------
is_delimiter:
    mov edx, 0              ; Устанавливаем флаг, что мы вне слова
    jmp next_char           ; Переходим к следующему символу

    ;----------------------------------------
    ; Подблок: Обработка продолжения слова
    ;----------------------------------------
continue_word:
    ; Если символ - часть текущего слова, просто продолжаем обработку

    ;----------------------------------------
    ; Подблок: Переход к следующему символу
    ;----------------------------------------
next_char:
    inc edi                 ; Увеличиваем индекс для перехода к следующему символу
    jmp count_loop          ; Продолжаем цикл подсчета

    ;==========================================
    ; БЛОК ФОРМАТИРОВАНИЯ РЕЗУЛЬТАТА
    ;==========================================
end_count:
    ;----------------------------------------
    ; Подблок: Конвертация числового результата в строку
    ;----------------------------------------
    mov eax, ebp            ; Копируем количество слов в eax для конвертации
    mov edi, result         ; Устанавливаем указатель на буфер результата
    mov ecx, 0              ; Инициализируем счетчик цифр

    ;----------------------------------------
    ; Подблок: Обработка особого случая - ноль слов
    ;----------------------------------------
    cmp eax, 0              ; Проверяем, равно ли количество слов нулю
    jne convert_loop        ; Если не ноль, переходим к стандартной конвертации
    mov byte [result], '0'  ; Записываем символ '0' в результат
    mov byte [result+1], 0  ; Завершаем строку нулевым байтом
    jmp show_result         ; Переходим к выводу результата

    ;----------------------------------------
    ; Подблок: Цикл конвертации числа в строку
    ;----------------------------------------
convert_loop:
    mov edx, 0              ; Очищаем edx перед делением (старшая часть делимого)
    mov ebx, 10             ; Устанавливаем делитель - основание системы счисления (10)
    div ebx                 ; Делим eax на 10: частное в eax, остаток в edx

    add dl, '0'             ; Конвертируем остаток (цифру) в ASCII символ
    push edx                ; Сохраняем цифру в стеке (в обратном порядке)
    inc ecx                 ; Увеличиваем счетчик цифр
    
    test eax, eax           ; Проверяем, не стал ли результат деления нулем
    jnz convert_loop        ; Если частное не ноль, продолжаем конвертацию

    ;----------------------------------------
    ; Подблок: Формирование строки результата
    ;----------------------------------------
    mov edi, result         ; Сбрасываем указатель на начало буфера результата

    ;----------------------------------------
    ; Подблок: Извлечение цифр из стека
    ;----------------------------------------
digit_to_string:
    pop eax                 ; Извлекаем цифру из стека
    mov [edi], al           ; Записываем символ в буфер результата
    inc edi                 ; Перемещаем указатель на следующую позицию в буфере
    dec ecx                 ; Уменьшаем счетчик цифр
    jnz digit_to_string     ; Если еще остались цифры, продолжаем извлечение

    mov byte [edi], 0       ; Добавляем завершающий нулевой символ

    ;==========================================
    ; БЛОК ВЫВОДА РЕЗУЛЬТАТОВ
    ;==========================================
show_result:
    ;----------------------------------------
    ; Подблок: Вывод сообщения о результате
    ;----------------------------------------
    mov eax, 4              ; sys_write - системный вызов для записи
    mov ebx, 1              ; stdout - файловый дескриптор стандартного вывода
    mov ecx, result_msg     ; указатель на сообщение "Количество слов: "
    mov edx, result_len     ; длина сообщения
    int 0x80                ; вызов функции ядра для вывода

    ;----------------------------------------
    ; Подблок: Определение длины строки результата
    ;----------------------------------------
    mov edx, 0              ; Инициализируем счетчик длины
length_loop:
    cmp byte [result + edx], 0  ; Проверяем, не достигли ли конца строки (нулевой байт)
    je length_done              ; Если нашли нулевой байт, завершаем подсчет длины
    inc edx                     ; Увеличиваем счетчик длины
    jmp length_loop             ; Продолжаем поиск конца строки

    ;----------------------------------------
    ; Подблок: Вывод результата
    ;----------------------------------------
length_done:
    mov eax, 4              ; sys_write - системный вызов для записи
    mov ebx, 1              ; stdout - файловый дескриптор стандартного вывода
    mov ecx, result         ; указатель на строку с результатом
    ; edx уже содержит длину строки результата
    int 0x80                ; вызов функции ядра для вывода

    ;----------------------------------------
    ; Подблок: Вывод перевода строки
    ;----------------------------------------
    mov eax, 4              ; sys_write - системный вызов для записи
    mov ebx, 1              ; stdout - файловый дескриптор стандартного вывода
    mov ecx, newline        ; указатель на символ перевода строки
    mov edx, 1              ; длина - один байт
    int 0x80                ; вызов функции ядра для вывода

    ;==========================================
    ; БЛОК ЗАВЕРШЕНИЯ ПРОГРАММЫ
    ;==========================================
    mov eax, 1              ; sys_exit - системный вызов для завершения программы
    xor ebx, ebx            ; статус 0 - успешное завершение
    int 0x80                ; вызов функции ядра для выхода из программы

; Добавление для предотвращения предупреждения о исполняемом стеке
section .note.GNU-stack noalloc noexec nowrite progbits
